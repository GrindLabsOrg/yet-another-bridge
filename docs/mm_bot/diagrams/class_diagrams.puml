@startuml

title MM Diagram Class
'hide members

class MM {
  + run()
}

package services {
  package ethereum {
    class Ethereum {
      __ main methods __
      + transfer(deposit_id, dst_addr, amount)
      + claim_payment(deposit_id, dst_addr, amount, value)
      + claim_payment_zksync(order_id, destination_address, amount, value, gas_limit, gas_per_pub_data_byte_limit)
      + get_is_used_order(order_id, recipient_address, amount, rpc_node): bool

      __ auxiliary methods __
      + get_latest_block(rpc_node): int
      + get_balance(rpc_node): int
      + has_funds(amount: int): bool
      + create_transfer(deposit_id, dst_addr_bytes, amount, rpc_node)
      + create_claim_payment(deposit_id, dst_addr_bytes, amount, value, rpc_node)
      + create_claim_payment_zksync(order_id, destination_address, amount, value, gas_limit, gas_per_pub_data_byte_limit, rpc_node)
      + get_nonce(w3: Web3, address)
      + estimate_transaction_fee(transaction, rpc_node)
      + get_gas_price(rpc_node)
      + has_enough_funds(amount: int, gas_fee: int): bool
      + send_raw_transaction(signed_tx, rpc_node)
      + wait_for_transaction_receipt(tx_hash, rpc_node)
    }

    class EthereumRpcNode {
      + w3
      + account
      + contract
    }
  }

  class Herodotus {
    + herodotus_prove(block, order_id, slot): str
    + herodotus_status(task_id): str
    + herodotus_poll_status(task_id): bool
  }

  class OrderService {
    + create_order(order: Order): Order
    + get_order(order_id, origin_network): Order | None
    + get_incomplete_orders(): list[Order]
    + get_failed_orders(): list[Order]
    + already_exists(order_id, origin_network): bool
    + set_order_processing(order: Order): Order
    + set_order_transferring(order: Order, tx_hash): Order
    + set_order_fulfilled(order: Order): Order
    + set_order_proving_herodotus(order: Order, task_id, block, slot): Order
    + set_order_proving_ethereum(order: Order, tx_hash): Order
    + set_order_proved(order: Order): Order
    + set_order_completed(order: Order): Order
    + set_order_dropped(order: Order): Order
    + set_order_failed(order: Order, error_message: str): Order
    + reset_failed_order(order: Order): Order
    + set_failed(order: Order, failed: bool): Order
  }


  package starknet {
    class Starknet {
      __ main methods __
      + get_starknet_events(from_block_number: Literal["pending", "latest"] | int | None,
                                  to_block_number: Literal["pending", "latest"] | int | None,
                                  continuation_token, rpc_node)
      + get_order_events(from_block_number, to_block_number): list[SetOrderEvent]
      + claim_payment(order_id, block, slot): bool

      __ auxiliary methods __
      + get_latest_block(rpc_node): int
      + sign_invoke_transaction(call: Call, max_fee: int, rpc_node)
      + estimate_message_fee(from_address, to_address, entry_point_selector, payload, rpc_node)
      + send_transaction(transaction, rpc_node)
      + wait_for_tx(transaction_hash, rpc_node)
    }

    class StarknetRpcNode {
      + full_node_client
      + account
      + contract_address
    }

    class MMFullNodeClient {
    }
  }

  package zksync {
    class Zksync {
      __ main methods __
      + get_set_order_events(from_block_number, to_block_number): list[SetOrderEvent]

      __ auxiliary methods __
      + get_latest_block(rpc_node): int
      + get_set_order_logs(from_block_number, to_block_number, rpc_node): list[EventData]
    }

  	class EthereumAsyncRpcNode {
      + w3
      + contract
  	}

  }

  package executors {
    class OrderExecutor {
      - logger
      - order_service
      - sender
      - payment_claimer
      - fee_calculator
      - eth_lock
      - herodotus_semaphore
      - MAX_ETH_TRANSFER_WEI

      + execute(order)
      - process_order(order)
    }
  }

  package fee_calculators {
    abstract FeeCalculator {
      + estimate_overall_fee(order: Order): int
      + estimate_transfer_fee(order: Order): int
      + estimate_claim_payment_fee(order: Order): int
      + {abstract} estimate_message_fee(order: Order): int
    }

    class StarknetFeeCalculator {
    }

    class ZksyncFeeCalculator {
      + estimate_gas_limit(order: Order): int
      + estimate_gas_per_pub_data_byte_limit(order: Order): int
    }
  }

  package indexers {
    abstract OrderIndexer {
      - logger
      - order_service

      + {abstract} get_orders(from_block, to_block): list[Order]
      + {abstract} get_new_orders(): list[Order]
      + save_orders(set_order_events: list[SetOrderEvent]): list[Order]
    }

    class StarknetOrderIndexer {
    }

    class ZksyncOrderIndexer {
    }
  }

  package payment_claimer {
   abstract PaymentClaimer {
      - logger

      + {abstract} send_payment_claim(order: Order, order_service: OrderService)
      + {abstract} wait_for_payment_claim(order: Order, order_service: OrderService)
      + {abstract} close_payment_claim(order: Order, order_service: OrderService)
    }

    class EthereumPaymentClaimer {
      - fee_calculator
    }

    class Ethereum2ZksyncPaymentClaimer {
      - fee_calculator
    }

    class HerodotusPaymentClaimer {
    }
  }

  package processors {
    class OrdersProcessor {
      - logger
      - order_indexer
      - order_executor

      + process_orders()
    }

    class AcceptedBlocksOrderProcessor {
      - logger
      - order_indexer
      - order_executor
      - block_dao

      + process_orders()
      + process_orders_job()
    }

    class FailedOrdersProcessor {
      - logger
      - order_executor
      - order_service

      + process_orders()
      + process_orders_job()
    }
  }

  package senders {
    class EthereumSender {
      - logger
      - order_service

      + transfer(order: Order)
      + wait_transfer(order: Order)
  }
}

package persistence <<Database>> {
  class BlockDao {
    + get_latest_block(network: Network): int
    + update_latest_block(latest_block: int, network: Network)
  }

  class ErrorDao {
    + create_error(error: Error): Error
  }

  class OrderDao {
    + create_order(order: Order): Order
    + get_order(order_id: int, origin_network: Network): Order | None
    + get_orders(criteria): list[Type[Order]]
    + get_incomplete_orders() list[Type[Order]]
    + get_failed_orders(): list[Type[Order]]
    + already_exists(order_id: int, origin_network: Network): bool
    + update_order(order: Order): Order
  }
}

package models {
  class Block {
    + id: int
    + network: Network
    + latest_block
    + created_at
  }

  class Error {
    + id: int
    + order_id: int
    + origin_network: Network
    + order: Mapped[Order]
    + message: str
    + created_at: datetime
  }

  enum Network {
    STARKNET
    ZKSYNC
  }

  class Order {
    + order_id: int
    + origin_network: Network
    + recipient_address: str
    + amount: decimal
    + fee: decimal
    + status: OrderStatus
    + failed: bool
    + set_order_tx_hash: HexBytes
    + transfer_tx_hash: HexBytes
    + claim_tx_hash: HexBytes
    + herodotus_task_id: str
    + herodotus_block: int
    + herodotus_slot: int
    + created_at: datetime
    + transferred_at: datetime
    + completed_at: datetime

    + get_int_amount(): int
    + get_int_fee(): int
    + summary(): str
    + {static} from_set_order_event(event: SetOrderEvent): Order
  }

  enum OrderStatus {
    PENDING
    PROCESSING
    TRANSFERRING
    FULFILLED
    PROVING
    PROVED
    COMPLETED
    DROPPED
  }

  class SetOrderEvent {
    + order_id: int
    + origin_network: Network
    + set_order_tx_hash: HexBytes
    + recipient_address: str
    + amount: int
    + fee: int
    + block_number: int
    + is_used: bool

    + {static} from_starknet(event): SetOrderEvent
    + {static} from_zksync(event): SetOrderEvent
    + {static} parse_u256_from_double_u128(low: int, high: int): int
  }
}

' Relations
' MM
MM *-down- FailedOrdersProcessor
MM *-down- AcceptedBlocksOrderProcessor
MM *-down- OrdersProcessor

' Services
' Executors
'OrderExecutor *-- OrderService
OrderExecutor *-- EthereumSender
OrderExecutor *-- PaymentClaimer
OrderExecutor *-- FeeCalculator

' Fee Calculator
'FeeCalculator *-- Ethereum
FeeCalculator <|-- StarknetFeeCalculator
FeeCalculator <|-- ZksyncFeeCalculator

'StarknetFeeCalculator *-- Starknet
'ZksyncFeeCalculator *-- Zksync

' Indexers
'OrderIndexer *-- OrderService
OrderIndexer <|-- StarknetOrderIndexer
OrderIndexer <|-- ZksyncOrderIndexer

'StarknetOrderIndexer *-- Starknet
'ZksyncOrderIndexer *-- Zksync

' Payment Claimer
PaymentClaimer <|-- EthereumPaymentClaimer
PaymentClaimer <|-- HerodotusPaymentClaimer
PaymentClaimer <|-- Ethereum2ZksyncPaymentClaimer
'EthereumPaymentClaimer *-- Ethereum
'EthereumPaymentClaimer *-- StarknetFeeCalculator
'Ethereum2ZksyncPaymentClaimer *-- Ethereum
'Ethereum2ZksyncPaymentClaimer *-- ZksyncFeeCalculator
'HerodotusPaymentClaimer *-- Herodotus

' Processors
OrdersProcessor *-- OrderIndexer
OrdersProcessor *-- OrderExecutor

'AcceptedBlocksOrderProcessor *-- OrderIndexer
'AcceptedBlocksOrderProcessor *-- OrderExecutor
'AcceptedBlocksOrderProcessor *-- BlockDao

'FailedOrdersProcessor *-- OrderExecutor
'FailedOrdersProcessor *-- OrderService

' Senders
'EthereumSender *-- OrderService
'EthereumSender *-- Ethereum

OrderService *-- OrderDao
OrderService *-- ErrorDao

Ethereum *-- EthereumRpcNode

Starknet *-- StarknetRpcNode
StarknetRpcNode *-- MMFullNodeClient

Zksync *-- EthereumAsyncRpcNode

' Models
Order *-- SetOrderEvent
Order *-- OrderStatus
Order *-- Network

Error *-- Order
Error *-- Network

Block *-- Network
@enduml
